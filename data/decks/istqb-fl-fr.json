{
  "id": "istqb-fl-fr",
  "title": "ISTQB Foundation (FR)",
  "description": "Cartes de révision — ISTQB Foundation Level (FR). Chapitre 1 : éléments & sujets (version enrichie).",
  "language": "fr",
  "schemaVersion": 2,
  "cards": [
    {
      "id": "001",
      "chapter": 1,
      "section": "1) Le test logiciel : définition et finalité",
      "level": "K1",
      "notion": "Test",
      "question": "Qu’est-ce que le test logiciel ?",
      "definition": "Le test est un ensemble d’activités visant à découvrir des défauts et à fournir des informations sur la qualité du produit. Le test ne prouve pas l’absence de défauts : il réduit l’incertitude et supporte la décision.",
      "exemple": "Exécuter un parcours de paiement et vérifier le résultat attendu (paiement accepté/rejeté correctement, messages d’erreur cohérents).",
      "a_retenir": [
        "Le test = détection + information",
        "Objectif : réduire le risque, pas “prouver que tout va bien”"
      ],
      "keywords": ["test", "qualité", "risque", "confiance", "décision"],
      "image": {
        "src": "assets/images/istqb-fl-fr/001.png",
        "alt": "Illustration du concept de test"
      }
    },
    {
      "id": "002",
      "chapter": 1,
      "section": "2) Pourquoi tester : valeur business et qualité",
      "level": "K1",
      "notion": "Erreur → Défaut → Défaillance",
      "question": "Quelle est la chaîne classique de cause à effet en qualité logicielle ?",
      "definition": "Une erreur humaine peut introduire un défaut (fault/bug) dans un artefact. Lors de l’exécution, ce défaut peut provoquer une défaillance (failure), c’est-à-dire un comportement observable incorrect.",
      "exemple": "Erreur : mauvaise compréhension d’une règle métier. Défaut : condition codée incorrecte. Défaillance : montant de remise faux en production.",
      "a_retenir": [
        "Défaut = imperfection dans l’artefact",
        "Défaillance = comportement observable incorrect"
      ],
      "keywords": ["erreur", "défaut", "bug", "défaillance", "failure"],
      "image": null
    },
    {
      "id": "003",
      "chapter": 1,
      "section": "5) Artefacts : testware et traçabilité",
      "level": "K1",
      "notion": "Cas de test",
      "question": "Qu’est-ce qu’un cas de test ?",
      "definition": "Un cas de test définit des préconditions, des entrées, des actions (si applicable), des résultats attendus et des postconditions, afin de vérifier un objectif de test.",
      "exemple": "Précondition : utilisateur connecté. Action : changer l’email. Attendu : email modifié + message OK + email de confirmation envoyé.",
      "a_retenir": [
        "Le résultat attendu est obligatoire",
        "Le cas de test vérifie un objectif précis"
      ],
      "keywords": ["cas de test", "résultat attendu", "précondition", "postcondition"],
      "image": null
    },
    {
      "id": "004",
      "chapter": 1,
      "section": "1) Le test logiciel : définition et finalité",
      "level": "K2",
      "notion": "Ce que le test n’est pas",
      "question": "Quelles confusions fréquentes faut-il éviter sur le test ?",
      "definition": "Le test n’est pas uniquement “chercher des bugs”, ni une phase finale. Ce n’est pas non plus du débogage. Le test est un processus continu qui apporte de l’information et du contrôle sur les risques.",
      "exemple": "Dire “on testera à la fin” = risque de découverte tardive. Dire “tester = corriger” = confusion avec le debug.",
      "a_retenir": [
        "Test ≠ debug",
        "Test ≠ activité unique en fin de projet"
      ],
      "keywords": ["test", "mythes", "debug", "phase finale"],
      "image": null
    },
    {
      "id": "005",
      "chapter": 1,
      "section": "1) Le test logiciel : définition et finalité",
      "level": "K1",
      "notion": "Objectifs du test",
      "question": "Quels sont les objectifs business du test ?",
      "definition": "Réduire le risque, fournir des informations pour la décision (go/no-go), augmenter la confiance, vérifier la conformité, et prévenir les défauts (via retours rapides et amélioration du process).",
      "exemple": "Avant une mise en prod, les résultats de tests servent à décider : déployer, retarder, ou réduire le scope.",
      "a_retenir": [
        "Décision = un output majeur du test",
        "Prévention = feedback + amélioration continue"
      ],
      "keywords": ["risque", "confiance", "décision", "conformité", "prévention"],
      "image": null
    },
    {
      "id": "006",
      "chapter": 1,
      "section": "1) Le test logiciel : définition et finalité",
      "level": "K1",
      "notion": "Test statique vs test dynamique",
      "question": "Quelle différence entre test statique et test dynamique ?",
      "definition": "Le test statique évalue des artefacts sans exécuter le code (revues, analyses). Le test dynamique exécute le logiciel pour observer son comportement.",
      "exemple": "Statique : revue d’une user story pour détecter ambiguïtés. Dynamique : exécution d’un test API sur un endpoint.",
      "a_retenir": [
        "Statique = sans exécution",
        "Dynamique = avec exécution"
      ],
      "keywords": ["statique", "dynamique", "revue", "exécution"],
      "image": null
    },
    {
      "id": "007",
      "chapter": 1,
      "section": "1) Le test logiciel : définition et finalité",
      "level": "K1",
      "notion": "Vérification vs Validation",
      "question": "Différence entre vérification et validation ?",
      "definition": "La vérification répond à “construit-on le produit correctement ?” (conformité aux spécifications). La validation répond à “construit-on le bon produit ?” (besoin utilisateur).",
      "exemple": "Vérification : format email conforme. Validation : le parcours de changement d’email est compréhensible et utile pour l’utilisateur.",
      "a_retenir": [
        "Vérification = conformité",
        "Validation = adéquation au besoin"
      ],
      "keywords": ["vérification", "validation", "spécification", "besoin"],
      "image": null
    },
    {
      "id": "008",
      "chapter": 1,
      "section": "1) Le test logiciel : définition et finalité",
      "level": "K1",
      "notion": "Tester vs déboguer",
      "question": "Comment enchaîner test et debug, et qui fait quoi ?",
      "definition": "Tester vise à détecter et rapporter des défauts. Déboguer (debug) vise à localiser, analyser et corriger la cause dans le code. Souvent : test → signalement → debug → correctif → re-test.",
      "exemple": "Le test détecte un crash sur iOS. Le dev reproduit, identifie la ligne fautive, corrige, puis le testeur revalide.",
      "a_retenir": [
        "Test = détection/constat",
        "Debug = analyse/correction"
      ],
      "keywords": ["test", "debug", "responsabilités", "retest"],
      "image": null
    }
  ]
}
